{% extends "annotator/base.html" %}

{% block extra_css %}

<style> 
    
</style>
{% endblock %}

{% block content %}
<div class="container-fluid content">
        {% if messages %}
            {% for message in messages %}
                <div class="alert alert-{{ message.tags }} alert-dismissible fade show" role="alert">
                    {{ message }}
                    
                </div>
            {% endfor %}
        {% endif %}

        
<div class="annotation-container">
    <div class="document-viewer" id="documentViewer">
        <div class="document-title">
            <h2>{{ document.title }}</h2>
            <p class="text-muted">
                Uploaded: {{ document.uploaded_at|date:"Y-m-d H:i" }} | 
                <a href="{% url 'document_list' %}">‚Üê Back to Documents</a> 
                <a href="{% url 'export_annotations' document.pk %}" style="display: none;">Export Annotations</a>
            </p>
        </div>
        
        <div id="htmlContent">
            {% autoescape off %}
            {{ html_content }}
            {% endautoescape %}
        </div>
        
        <div class="zoom-controls">
            <button id="zoomOut" title="Zoom Out" class="zoom-btn">‚àí</button>
            <span class="zoom-level" id="zoomLevel">100%</span>
            <button id="zoomIn" title="Zoom In" class="zoom-btn">+</button>
            <button id="zoomReset" title="Reset Zoom" class="zoom-btn zoom-reset">Reset</button>
        </div>
    </div>
    
    <div class="annotation-panel">
        <!-- Scrollable Content -->
        <div class="panel-scrollable">
            <!-- Categories Section -->
            <div class="panel-section">
                <div class="panel-section-title">üè∑Ô∏è Categories</div>
                <div id="categoryList">
                    {% for category in categories %}
                        {% if not category.parent %}
                        <div class="category-group collapsed" data-category-name="{{ category.name }}">
                            <div class="category-parent-header" >
                                <div class="category-parent-info" style="border-left-color: {{ category.color }};">
                                    <span class="category-parent-name">{{ category.name }}</span>
                                    <span class="category-count-badge" data-count-for="{{ category.name }}">0</span>
                                </div>
                                <div class="category-collapse-icon">‚ñº</div>
                            </div>
                            <div class="category-children">
                                {% for subcategory in categories %}
                                    {% if subcategory.parent and subcategory.parent.id == category.id %}
                                    <div class="category-child-item category-option subcategory" style="background-color: {{ subcategory.color }}15; border-left: 3px solid {{ subcategory.color }};" data-category-name="{{ subcategory.name }}">
                                        <strong>{{ subcategory.name }}</strong>
                                        <span class="category-count-badge" data-count-for="{{ subcategory.name }}">0</span>
                                        {% if subcategory.description %}
                                        <div class="subcategory-description">{{ subcategory.description }}</div>
                                        {% endif %}
                                    </div>
                                    {% endif %}
                                {% endfor %}
                            </div>
                        </div>
                        {% endif %}
                    {% endfor %}
                    
                    {% if not categories %}
                    <p class="text-muted">No categories defined. Please add categories in the admin panel.</p>
                    {% endif %}
                </div>
            </div>
            
            <!-- Annotations Section -->
            <div class="panel-section">
                <div class="panel-section-title">
                    üìã Annotations
                    <button class="info-button" id="showInstructionsBtn" title="How to Annotate">i</button>
                </div>
                <div id="annotationList">
                    {% for annotation in annotations %}
                    <div class="annotation-item" data-annotation-id="{{ annotation.id }}">
                        <div class="category-badge" style="background-color: {{ annotation.category.color|default:'#007bff' }}90;">
                            {{ annotation.category.name }}
                        </div>
                        <div class="text-preview">"{{ annotation.selected_text|truncatewords:15 }}"</div>
                        <small class="text-muted">{{ annotation.created_at|date:"Y-m-d H:i" }}</small>
                        <div class="float-end">
                            <button class="btn btn-sm btn-outline-secondary edit-annotation me-1" data-id="{{ annotation.id }}" data-category="{{ annotation.category.name }}">Edit</button>
                            <button class="btn btn-sm btn-danger delete-annotation" data-id="{{ annotation.id }}">Delete</button>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="deleteModal" class="delete-modal">
    <div class="delete-modal-content">
        <div class="delete-modal-header">
            <span class="delete-modal-icon">‚ö†Ô∏è</span>
            <h3>Delete Annotation</h3>
        </div>
        <div class="delete-modal-body">
            <p class="delete-modal-message">Are you sure you want to delete this annotation? This action cannot be undone.</p>
            <div class="delete-modal-info">
                <div class="delete-modal-info-label">Category:</div>
                <div class="delete-modal-info-value" id="deleteModalCategory"></div>
            </div>
            <div class="delete-modal-info">
                <div class="delete-modal-info-label">Selected Text:</div>
                <div class="delete-modal-info-value" id="deleteModalText"></div>
            </div>
        </div>
        <div class="delete-modal-footer">
            <button class="delete-modal-btn delete-modal-btn-cancel" id="deleteModalCancel">Cancel</button>
            <button class="delete-modal-btn delete-modal-btn-delete" id="deleteModalConfirm">Delete Annotation</button>
        </div>
    </div>
</div>

<!-- Edit Annotation Modal -->
<div id="editModal" class="delete-modal">
    <div class="delete-modal-content">
        <div class="delete-modal-header">
            <span class="delete-modal-icon">‚úèÔ∏è</span>
            <h3>Edit Annotation Category</h3>
        </div>
        <div class="delete-modal-body">
            <p class="delete-modal-message">Select a new category for this annotation:</p>
            <div class="form-group" style="margin-top: 15px;">
                <select id="editCategorySelect" class="form-select" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
                     {% for category in categories %}
                        <option value="{{ category.name }}"
                            {% if not category.parent %}
                                style="font-weight: bold; background-color: #eeeeee; color: #000;"
                            {% else %}
                                style="padding-left: 10px;"
                            {% endif %}>
                            {% if category.parent %}&nbsp;&nbsp;&nbsp; - {% endif %}{{ category.name }}
                        </option>
                     {% endfor %}
                </select>
            </div>
        </div>
        <div class="delete-modal-footer">
            <button class="delete-modal-btn delete-modal-btn-cancel" id="editModalCancel">Cancel</button>
            <button class="delete-modal-btn delete-modal-btn-delete" style="background-color: #3498db;" id="editModalSave">Save Changes</button>
        </div>
    </div>
</div>

<!-- Action Choice Modal -->
<div id="actionChoiceModal" class="delete-modal">
    <div class="delete-modal-content">
        <div class="delete-modal-header">
            <span class="delete-modal-icon">‚öôÔ∏è</span>
            <h3>Manage Annotation</h3>
        </div>
        <div class="delete-modal-body">
            <p class="delete-modal-message">What would you like to do with this annotation?</p>
            <div class="delete-modal-info">
                <div class="delete-modal-info-label">Category:</div>
                <div class="delete-modal-info-value" id="actionChoiceCategory"></div>
            </div>
            <div class="delete-modal-info">
                <div class="delete-modal-info-label">Text:</div>
                <div class="delete-modal-info-value" id="actionChoiceText"></div>
            </div>
        </div>
        <div class="delete-modal-footer">
            <button class="delete-modal-btn delete-modal-btn-cancel" id="actionChoiceCancel">Cancel</button>
            <div style="flex-grow: 1;"></div>
            <button class="delete-modal-btn delete-modal-btn-delete" style="background-color: #3498db; margin-right: 10px;" id="actionChoiceEdit">Change Category</button>
            <button class="delete-modal-btn delete-modal-btn-delete" id="actionChoiceDelete">Delete</button>
        </div>
    </div>
</div>

<!-- Category Selector Popup -->
<div id="categorySelector" class="category-selector">
    <div class="category-selector-header">
        <div class="category-selector-title">Select Category:</div>
        <button class="category-selector-close" id="categorySelectorClose" title="Close (Esc)">√ó</button>
    </div>
    <div id="suggestedCategoriesSection" style="display:none; padding: 10px; border-bottom: 1px solid #ddd; background-color: #f8f9fa;">
        <div style="font-weight: bold; margin-bottom: 5px; font-size: 0.85em; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">‚ú® Suggested Categories</div>
        <div id="suggestedCategoriesList"></div>
    </div>
    <div id="categorySelectorOptions">
        {% for category in categories %}
        <div class="category-option {% if not category.parent %}parent-category{% else %}subcategory{% endif %}" data-category="{{ category.name }}" data-category-name="{{ category.name }}" style="border-left: 4px solid {{ category.color }};"
        {% if category.parent and category.description %} data-toggle="tooltip" data-placement="right" title="{{ category.description }}"{% endif %}>
            {{ category.name }}
            <span class="category-count-badge" data-count-for="{{ category.name }}">0</span>
        </div>
        {% endfor %}
    </div>

</div>

<!-- How to Annotate Instructions Modal -->
<div id="instructionsModal" class="instructions-modal">
    <div class="instructions-modal-header">
        <h3>üìù How to Annotate</h3>
        <button class="instructions-modal-close" id="closeInstructionsBtn">√ó</button>
    </div>
    <div class="instructions-modal-body">
        <ol>
            <li>Select text in the document</li>
            <li>Choose a category from the popup</li>
            <li>Annotation is saved automatically</li>
            <li>Click on annotations to delete them</li>
        </ol>
    </div>
</div>
</div>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Initialize tooltips for category descriptions
    $(function () {
        $('[data-toggle="tooltip"]').tooltip({
            boundary: 'window',
            container: 'body',
            html: false,
            trigger: 'hover focus'
        });
    });
    const documentViewer = document.getElementById('documentViewer');
    const categorySelector = document.getElementById('categorySelector');
    const annotationList = document.getElementById('annotationList');
    let currentSelection = null;
    let currentRange = null;
    let currentEmbedding = null;
    
    let currentZoom = 1.0;
    const zoomStep = 0.2;
    const minZoom = 0.5;
    const maxZoom = 3.0;
    
    const htmlContent = document.getElementById('htmlContent');
    const zoomWrapper = document.getElementById('zoomWrapper');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const zoomResetBtn = document.getElementById('zoomReset');
    const zoomLevelDisplay = document.getElementById('zoomLevel');
    
    function updateZoom(newZoom) {
        currentZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
        
        htmlContent.style.transform = `scale(${currentZoom})`;
        htmlContent.style.transformOrigin = 'top left';
        htmlContent.style.transition = 'transform 0.2s ease';
        
        // Adjust wrapper to accommodate scaled content
        htmlContent.style.width = `${100 / currentZoom}%`;
        htmlContent.style.minHeight = `${100 / currentZoom}%`;
        
        zoomLevelDisplay.textContent = Math.round(currentZoom * 100) + '%';
        
        // Update button states
        zoomInBtn.disabled = currentZoom >= maxZoom;
        zoomOutBtn.disabled = currentZoom <= minZoom;
    }
    
    zoomInBtn.addEventListener('click', () => {
        updateZoom(currentZoom + zoomStep);
    });
    
    zoomOutBtn.addEventListener('click', () => {
        updateZoom(currentZoom - zoomStep);
    });
    
    zoomResetBtn.addEventListener('click', () => {
        updateZoom(1.0);
    });
    
    // Keyboard shortcuts for zoom
    /*
    TODO da rivedere gli shortcut, pdfhtmlEX fornisce gli shortcut che quindi vanno in conflitto con il nostro zoom
    document.addEventListener('keydown', (e) => {
        // Ctrl/Cmd + Plus/Equals for zoom in
        if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=')) {
            e.preventDefault();
            updateZoom(currentZoom + zoomStep);
        }
        // Ctrl/Cmd + Minus for zoom out
        else if ((e.ctrlKey || e.metaKey) && e.key === '-') {
            e.preventDefault();
            updateZoom(currentZoom - zoomStep);
        }
        // Ctrl/Cmd + 0 for reset zoom
        else if ((e.ctrlKey || e.metaKey) && e.key === '0') {
            e.preventDefault();
            updateZoom(1.0);
        }
    });*/
    
    // Mouse wheel zoom (Ctrl + wheel)
    documentViewer.addEventListener('wheel', (e) => {
        if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -zoomStep : zoomStep;
            updateZoom(currentZoom + delta);
        }
    }, { passive: false });
    
    // Initialize button states without applying transform
    zoomInBtn.disabled = currentZoom >= maxZoom;
    zoomOutBtn.disabled = currentZoom <= minZoom;
    
    // CSRF token for POST requests
    const csrfToken = '{{ csrf_token }}';
    
    // console.log('CSRF Token loaded:', csrfToken ? 'Yes' : 'No');
    // console.log('CSRF Token length:', csrfToken.length);
    
    // Category colors mapping
    const categoryColors = {
        {% for category in categories %}
        '{{ category.name }}': '{{ category.color }}',
        {% endfor %}
    };
    
    // Store existing annotations
    const existingAnnotations = [
        {% for ann in annotations_data %}
        {
            id: {{ ann.id }},
            category: '{{ ann.category_name|escapejs }}',
            text: '{{ ann.selected_text|escapejs }}',
            color: '{{ ann.category_color }}',
            positionData: {{ ann.position_data|safe }}
        }{% if not forloop.last %},{% endif %}
        {% endfor %}
    ];
    
    // Text selection handler
    documentViewer.addEventListener('mouseup', function(e) {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        if (selectedText.length > 0) {
            currentSelection = selectedText;
            currentRange = selection.getRangeAt(0);
            
            // Log selection details for debugging
            console.log('Text selected:', {
                length: selectedText.length,
                starts: selectedText.substring(0, 50),
                ends: selectedText.substring(selectedText.length - 50)
            });
            
            // Show category selector at fixed position: mid-left of the screen
            categorySelector.style.display = 'block';
            
            // Re-initialize tooltips for category descriptions
            $('[data-toggle="tooltip"]').tooltip('dispose');
            $('[data-toggle="tooltip"]').tooltip({
                boundary: 'window',
                container: 'body',
                html: false,
                trigger: 'hover focus'
            });
            
            // Position at left: 20px from left edge, vertically centered
            const viewportHeight = window.innerHeight;
            const selectorHeight = categorySelector.offsetHeight || 300; // estimated height if not rendered yet
            
            categorySelector.style.left = '20px';
            categorySelector.style.top = Math.max(20, (viewportHeight - selectorHeight) / 2) + 'px';
            
            // Update selector with preview
            const previewEl = document.getElementById('selectionPreview');
            if (!previewEl) {
                const preview = document.createElement('div');
                preview.id = 'selectionPreview';
                preview.style.cssText = 'font-size:0.85em; color:#666; margin-bottom:8px; padding:8px; background:#f0f0f0; border-radius:4px; max-height:60px; overflow:auto;';
                categorySelector.insertBefore(preview, categorySelector.firstChild);
            }
            const finalPreview = document.getElementById('selectionPreview');
            finalPreview.textContent = `"${selectedText.substring(0, 100)}${selectedText.length > 100 ? '...' : ''}"`;
            
            // Reset and fetch suggestions
            const suggestedSection = document.getElementById('suggestedCategoriesSection');
            if (suggestedSection) suggestedSection.style.display = 'none';
            currentEmbedding = null; // Reset embedding
            fetchSuggestions(selectedText);
        }
    });
    
    // Hide selector when clicking outside
    document.addEventListener('mousedown', function(e) {
        if (!categorySelector.contains(e.target) && e.target !== documentViewer) {
            closeCategorySelector();
        }
    });
    
    // Close button handler
    document.getElementById('categorySelectorClose').addEventListener('click', function(e) {
        e.stopPropagation();
        closeCategorySelector();
    });
    
    // ESC key handler
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && categorySelector.style.display === 'block') {
            closeCategorySelector();
        }
    });
    
    // Function to close category selector
    function closeCategorySelector() {
        categorySelector.style.display = 'none';
        // Clear the current selection
        window.getSelection().removeAllRanges();
        currentSelection = null;
        currentRange = null;
    }
    
    // Custom delete confirmation modal
    const deleteModal = document.getElementById('deleteModal');
    const deleteModalCategory = document.getElementById('deleteModalCategory');
    const deleteModalText = document.getElementById('deleteModalText');
    const deleteModalConfirm = document.getElementById('deleteModalConfirm');
    const deleteModalCancel = document.getElementById('deleteModalCancel');
    
    function showDeleteModal(category, text) {
        return new Promise((resolve) => {
            deleteModalCategory.textContent = category;
            deleteModalText.textContent = text;
            deleteModal.classList.add('active');
            
            const handleConfirm = () => {
                cleanup();
                resolve(true);
            };
            
            const handleCancel = () => {
                cleanup();
                resolve(false);
            };
            
            const cleanup = () => {
                deleteModal.classList.remove('active');
                deleteModalConfirm.removeEventListener('click', handleConfirm);
                deleteModalCancel.removeEventListener('click', handleCancel);
                deleteModal.removeEventListener('click', handleBackdropClick);
                document.removeEventListener('keydown', handleEscape);
            };
            
            const handleBackdropClick = (e) => {
                if (e.target === deleteModal) {
                    handleCancel();
                }
            };
            
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    handleCancel();
                }
            };
            
            deleteModalConfirm.addEventListener('click', handleConfirm);
            deleteModalCancel.addEventListener('click', handleCancel);
            deleteModal.addEventListener('click', handleBackdropClick);
            document.addEventListener('keydown', handleEscape);
        });
    }
    
    // Edit annotation handlers
    const editModal = document.getElementById('editModal');
    const editCategorySelect = document.getElementById('editCategorySelect');
    const editModalCancel = document.getElementById('editModalCancel');
    const editModalSave = document.getElementById('editModalSave');
    let editingAnnotationId = null;

    // Attach click handler for "Edit" buttons
    // Note: Since we reload the page often, or manipulate the list, delegated event handling is safer if list is dynamic.
    // But currently loop is static mostly unless we add via JS. Let's use annotationList for delegation.
    
    // Instructions Modal Handlers
    const instructionsModal = document.getElementById('instructionsModal');
    const showInstructionsBtn = document.getElementById('showInstructionsBtn');
    const closeInstructionsBtn = document.getElementById('closeInstructionsBtn');
    
    function positionInstructionsModal() {
        const btnRect = showInstructionsBtn.getBoundingClientRect();
        const modalWidth = 320;
        const offset = 10;
        
        // Position below the button
        instructionsModal.style.top = (btnRect.bottom + offset) + 'px';
        
        // Position to the left of the button, but check if it fits
        let leftPos = btnRect.left - modalWidth + btnRect.width;
        
        // If it goes off screen to the left, align with button's left
        if (leftPos < 10) {
            leftPos = btnRect.left;
        }
        
        // If it goes off screen to the right, align to the right edge
        if (leftPos + modalWidth > window.innerWidth - 10) {
            leftPos = window.innerWidth - modalWidth - 10;
        }
        
        instructionsModal.style.left = leftPos + 'px';
    }
    
    showInstructionsBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        positionInstructionsModal();
        instructionsModal.classList.add('show');
    });
    
    closeInstructionsBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        instructionsModal.classList.remove('show');
    });
    
    // Close modal when clicking outside
    document.addEventListener('click', function(e) {
        if (instructionsModal.classList.contains('show') && 
            !instructionsModal.contains(e.target) && 
            e.target !== showInstructionsBtn) {
            instructionsModal.classList.remove('show');
        }
    });
    
    // Close modal with ESC key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && instructionsModal.classList.contains('show')) {
            instructionsModal.classList.remove('show');
        }
    });
    
    annotationList.addEventListener('click', function(e) {
        // Handle Delete
        if (e.target.classList.contains('delete-annotation')) {
             const id = e.target.getAttribute('data-id');
             deleteAnnotation(id);
        }
        
        // Handle Edit
        if (e.target.classList.contains('edit-annotation')) {
             const id = e.target.getAttribute('data-id');
             const currentCategory = e.target.getAttribute('data-category');
             openEditModal(id, currentCategory);
        }
    });

    function openEditModal(id, currentCategory) {
        editingAnnotationId = id;
        editCategorySelect.value = currentCategory;
        editModal.classList.add('active');
        
        // Focus for keyboard accessibility
        editCategorySelect.focus();
        
        // Add escape key handler specifically for this modal
        const handleEscapeEdit = (e) => {
             if (e.key === 'Escape') closeEditModal();
        };
        document.addEventListener('keydown', handleEscapeEdit);
        
        // Store reference to clean up
        editModal.handleEscape = handleEscapeEdit;
    }

    function closeEditModal() {
        editModal.classList.remove('active');
        editingAnnotationId = null;
        if (editModal.handleEscape) {
            document.removeEventListener('keydown', editModal.handleEscape);
            editModal.handleEscape = null;
        }
    }

    editModalCancel.addEventListener('click', closeEditModal);

    editModalSave.addEventListener('click', async function() {
        if (!editingAnnotationId) return;
        
        const newCategory = editCategorySelect.value;
        if (!newCategory) return;
        
        const updateUrl = `{% url 'update_annotation' pk=document.pk annotation_id=0 %}`.replace('0', editingAnnotationId);
        
        try {
            editModalSave.textContent = 'Saving...';
            editModalSave.disabled = true;
            
            const response = await fetch(updateUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify({ category: newCategory })
            });
            
            const result = await response.json();
            
            if (response.ok && result.status === 'success') {
                // 1. Update internal data
                const targetAnn = existingAnnotations.find(a => a.id === parseInt(editingAnnotationId));
                if (targetAnn) {
                    targetAnn.category = newCategory;
                    targetAnn.color = categoryColors[newCategory];
                }

                // 2. Update the List Item (Sidebar)
                // This updates the badge text/color but leaves the item background alone
                const listItem = document.querySelector(`.annotation-item[data-annotation-id="${editingAnnotationId}"]`);
                if (listItem) {
                    const badge = listItem.querySelector('.category-badge');
                    const editBtn = listItem.querySelector('.edit-annotation');
                    
                    if (badge) {
                        badge.textContent = newCategory;
                        badge.style.backgroundColor = categoryColors[newCategory]+'90'; // Add transparency for badge background
                    }
                    if (editBtn) {
                        editBtn.setAttribute('data-category', newCategory);
                    }
                    // Explicitly clear any background style if it was wrongly added previously
                    listItem.style.background = '';
                    listItem.style.borderBottom = '';
                    listItem.style.boxShadow = ''; 
                }

                // 3. Update Document Highlights ONLY
                // FIX: Added '.highlight' class to selector so we don't target sidebar items
                const highlights = document.querySelectorAll(`.highlight[data-annotation-id]`);
                
                highlights.forEach(span => {
                    const idAttr = span.getAttribute('data-annotation-id');
                    if (!idAttr) return;

                    const ids = idAttr.split(',');
                    const index = ids.indexOf(String(editingAnnotationId));

                    if (index !== -1) {
                        const catAttr = span.getAttribute('data-category');
                        const cats = (catAttr || '').split(',');

                        while (cats.length <= index) cats.push('');
                        cats[index] = newCategory;
                        span.setAttribute('data-category', cats.join(','));

                        // Re-apply Highlight Styling
                        const currentColors = ids.map(id => {
                            const ann = existingAnnotations.find(a => a.id === parseInt(id));
                            return ann ? ann.color : '#cccccc';
                        });

                        if (currentColors.length === 1) {
                            const color = currentColors[0];
                            span.style.background = hexToRGBA(color, 0.3);
                            span.style.backgroundColor = hexToRGBA(color, 0.3);
                            span.style.borderBottom = `2px solid ${color}`;
                            span.style.boxShadow = '';
                        } else {
                            const gradientStops = currentColors.map((color, idx) => {
                                const start = (idx / currentColors.length) * 100;
                                const end = ((idx + 1) / currentColors.length) * 100;
                                return `${hexToRGBA(color, 0.3)} ${start}%, ${hexToRGBA(color, 0.3)} ${end}%`;
                            }).join(', ');

                            span.style.background = `linear-gradient(to bottom, ${gradientStops})`;
                            span.style.borderBottom = `2px solid ${currentColors[0]}`;
                            span.style.boxShadow = `inset 0 -4px 0 -2px ${currentColors[currentColors.length - 1]}`;
                        }
                        
                        span.title = cats.join(', ') + ' - Click to manage';
                    }
                });

                // 4. Update Stats and Notify
                updateStats();
                showNotification('Annotation updated successfully', 'success');

            } else {
                showNotification('Error updating annotation: ' + (result.message || 'Unknown error'), 'error');
            }
        } catch(error) {
            console.error('Error updating:', error);
            showNotification('Network error occurred', 'error');
        } finally {
             editModalSave.textContent = 'Save Changes';
             editModalSave.disabled = false;
             closeEditModal();
        }
    });

    // Action Choice Modal handlers
    const actionChoiceModal = document.getElementById('actionChoiceModal');
    const actionChoiceCategory = document.getElementById('actionChoiceCategory');
    const actionChoiceText = document.getElementById('actionChoiceText');
    const actionChoiceCancel = document.getElementById('actionChoiceCancel');
    const actionChoiceEdit = document.getElementById('actionChoiceEdit');
    const actionChoiceDelete = document.getElementById('actionChoiceDelete');
    
    let currentActionAnnotationId = null;

    function openActionChoiceModal(annotationId) {
        // Handle comma-separated IDs (overlapping annotations)
        const ids = String(annotationId).split(',');
        let targetId = null;
        let annotation = null;
        
        // Find first valid annotation that exists in our list
        for (const id of ids) {
             const found = existingAnnotations.find(a => a.id === parseInt(id));
             if (found) {
                 targetId = id;
                 annotation = found;
                 break;
             }
        }
        
        // If we can't find it in existingAnnotations (maybe it was just added but list not updated? 
        // normally saveAnnotation updates list), try to infer category?
        // But for now, let's rely on finding it.
        
        if (!annotation) {
             console.warn("Could not find annotation data for ID:", annotationId);
             // Verify if we can still offer delete?
             currentActionAnnotationId = ids[0];
             actionChoiceCategory.textContent = "Unknown";
             actionChoiceText.textContent = "Could not retreive details";
        } else {
             currentActionAnnotationId = targetId;
             actionChoiceCategory.textContent = annotation.category;
             actionChoiceText.textContent = `"${annotation.text.substring(0, 100)}${annotation.text.length > 100 ? '...' : ''}"`;
        }
        
        actionChoiceModal.classList.add('active');
        
        // Setup escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') closeActionChoiceModal();
        };
        document.addEventListener('keydown', handleEscape);
        actionChoiceModal.handleEscape = handleEscape;
    }
    
    function closeActionChoiceModal() {
        actionChoiceModal.classList.remove('active');
        currentActionAnnotationId = null;
        if (actionChoiceModal.handleEscape) {
            document.removeEventListener('keydown', actionChoiceModal.handleEscape);
            actionChoiceModal.handleEscape = null;
        }
    }
    
    actionChoiceCancel.addEventListener('click', closeActionChoiceModal);
    
    actionChoiceEdit.addEventListener('click', () => {
        const id = currentActionAnnotationId;
        const annotation = existingAnnotations.find(a => a.id === parseInt(id));
        closeActionChoiceModal();
        if (annotation) {
            openEditModal(id, annotation.category);
        } else if (id) {
             // Fallback if we have ID but no object (shouldn't happen often)
             // We need category for edit modal... maybe fetch or guess?
             // Since edit modal needs current category selected, if we don't know it, maybe default to first?
             openEditModal(id, "");
        }
    });
    
    actionChoiceDelete.addEventListener('click', () => {
        const id = currentActionAnnotationId;
        closeActionChoiceModal();
        if (id) {
            deleteAnnotation(id);
        }
    });
    
    // Close on backdrop click
    actionChoiceModal.addEventListener('click', (e) => {
        if (e.target === actionChoiceModal) closeActionChoiceModal();
    });

    // Category selection handler
    document.querySelectorAll('#categorySelectorOptions .category-option').forEach(option => {
        option.addEventListener('click', function() {
            const category = this.dataset.category;
            saveAnnotation(category);
            categorySelector.style.display = 'none';
        });
    });
    
    // Save annotation function
    async function saveAnnotation(category) {
        if (!currentSelection || !currentRange) return;
        
        // Get category color
        const color = categoryColors[category] || '#ffeb3b';
        
        console.log('Saving annotation:', {
            category: category,
            color: color,
            text: currentSelection.substring(0, 80)
        });
        
        // Get the actual text nodes at the start and end of the selection
        let startNode = currentRange.startContainer;
        let endNode = currentRange.endContainer;
        
        // If the container is an element, find the text node at the offset
        if (startNode.nodeType === Node.ELEMENT_NODE) {
            startNode = startNode.childNodes[currentRange.startOffset] || startNode.firstChild;
            // Find the first text node
            while (startNode && startNode.nodeType !== Node.TEXT_NODE) {
                startNode = startNode.firstChild || startNode.nextSibling;
            }
        }
        
        if (endNode.nodeType === Node.ELEMENT_NODE) {
            endNode = endNode.childNodes[currentRange.endOffset - 1] || endNode.lastChild;
            // Find the last text node
            while (endNode && endNode.nodeType !== Node.TEXT_NODE) {
                endNode = endNode.lastChild || endNode.previousSibling;
            }
        }
        
        // Get XPath for the text nodes
        const startXPath = startNode ? getXPath(startNode) : '';
        const endXPath = endNode ? getXPath(endNode) : '';
        
        // Get the actual offsets within the text nodes
        let actualStartOffset = currentRange.startOffset;
        let actualEndOffset = currentRange.endOffset;
        
        // If we had to find a different node, adjust offset
        if (currentRange.startContainer !== startNode) {
            actualStartOffset = 0;
        }
        if (currentRange.endContainer !== endNode) {
            actualEndOffset = endNode ? endNode.length : 0;
        }
        
        console.log('XPath info:', {
            startXPath: startXPath.substring(0, 50),
            endXPath: endXPath.substring(0, 50),
            hasValidXPath: !!(startXPath && endXPath)
        });
        
        // Store the range info for later use
        const rangeInfo = {
            startXPath: startXPath,
            endXPath: endXPath,
            startOffset: actualStartOffset,
            endOffset: actualEndOffset,
            text: currentSelection,
            category: category,
            color: color
        };
        
        const data = {
            category: category,
            selectedText: currentSelection,
            htmlSelector: '',
            positionData: {
                startXPath: startXPath,
                endXPath: endXPath,
                startOffset: actualStartOffset,
                endOffset: actualEndOffset
            },
            embedding: currentEmbedding
        };
        
        console.log('Sending data to server:', {
            category: data.category,
            textLength: data.selectedText.length,
            hasXPath: !!(startXPath && endXPath),
            hasEmbedding: !!currentEmbedding
        });
        
        try {
            const response = await fetch('{% url "save_annotation" document.pk %}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify(data)
            });
            
            console.log('Response status:', response.status);
            console.log('Response ok:', response.ok);
            
            const result = await response.json();
            console.log('Response data:', result);
            
            if (result.status === 'success') {
                // Add to existingAnnotations array
                existingAnnotations.push({
                    id: result.annotation_id,
                    category: category,
                    text: currentSelection,
                    color: color,
                    positionData: rangeInfo
                });
                // Apply highlight using the same XPath method that works on page load
                highlightUsingXPath({
                    id: result.annotation_id,
                    category: rangeInfo.category,
                    text: rangeInfo.text,
                    color: rangeInfo.color
                }, rangeInfo);
                
                addAnnotationToList(result.annotation_id, category, currentSelection);
                updateStats();
                showNotification('Annotation saved successfully', 'success');
            } else {
                console.error('Server error:', result);
                showNotification('Error saving annotation: ' + result.message, 'error');
            }
        } catch (error) {
            console.error('Error:', error);
            showNotification('Error saving annotation: ' + error.message, 'error');
        }
        
        // Clear selection
        window.getSelection().removeAllRanges();
        currentSelection = null;
        currentRange = null;
        currentEmbedding = null;
    }
    
    // Get XPath for a node
    function getXPath(node) {
        if (!node) return '';
        
        // If it's a text node, get path to its parent and then add text() selector
        if (node.nodeType === Node.TEXT_NODE) {
            const parent = node.parentNode;
            if (!parent) return '';
            
            // Find the text node index among siblings
            let textIndex = 0;
            for (let i = 0; i < parent.childNodes.length; i++) {
                if (parent.childNodes[i] === node) {
                    break;
                }
                if (parent.childNodes[i].nodeType === Node.TEXT_NODE) {
                    textIndex++;
                }
            }
            
            const parentPath = getXPath(parent);
            return `${parentPath}/text()[${textIndex + 1}]`;
        }
        
        // For element nodes
        if (node.id) {
            return `//*[@id="${node.id}"]`;
        }
        
        const parts = [];
        let currentNode = node;
        
        while (currentNode && currentNode.nodeType === Node.ELEMENT_NODE) {
            let index = 0;
            let sibling = currentNode.previousSibling;
            
            while (sibling) {
                if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName === currentNode.nodeName) {
                    index++;
                }
                sibling = sibling.previousSibling;
            }
            
            const tagName = currentNode.nodeName.toLowerCase();
            const pathIndex = index > 0 ? `[${index + 1}]` : '';
            parts.unshift(tagName + pathIndex);
            currentNode = currentNode.parentNode;
        }
        
        return parts.length ? '/' + parts.join('/') : '';
    }
    
    // Get node from XPath
    function getNodeFromXPath(xpath) {
        try {
            const result = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
            return result.singleNodeValue;
        } catch (e) {
            console.error('XPath evaluation failed:', e);
            return null;
        }
    }
    
    // Add annotation to the list
    function addAnnotationToList(id, category, text) {
        const color = categoryColors[category] || '#007bff';
        const annotationItem = document.createElement('div');
        annotationItem.className = 'annotation-item';
        annotationItem.dataset.annotationId = id;
        annotationItem.innerHTML = `
            <div class="category-badge" style="background-color: ${color}90;">
                ${category}
            </div>
            <div class="text-preview">"${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"</div>
            <button class="btn btn-sm btn-outline-secondary edit-annotation me-1" data-id="${id}" data-category="${category}">Edit</button>
            <button class="btn btn-sm btn-danger float-end delete-annotation" data-id="${id}">Delete</button>
        `;
        
        annotationList.insertBefore(annotationItem, annotationList.firstChild);
        
        // Add delete handler
        annotationItem.querySelector('.delete-annotation').addEventListener('click', function() {
            deleteAnnotation(id);
        });
    }
    
    // Delete annotation
    async function deleteAnnotation(annotationId) {
        // Get annotation details for modal
        const annotationElement = document.querySelector(`.annotation-item[data-annotation-id="${annotationId}"]`);
        let category = 'Unknown';
        let text = 'No text available';
        
        if (annotationElement) {
            const categoryBadge = annotationElement.querySelector('.category-badge');
            const textPreview = annotationElement.querySelector('.text-preview');
            
            if (categoryBadge) {
                category = categoryBadge.textContent.trim();
            }
            if (textPreview) {
                text = textPreview.textContent.trim().replace(/^"|"$/g, ''); // Remove quotes
            }
        }
        
        // Show custom modal and wait for user response
        const confirmed = await showDeleteModal(category, text);
        if (!confirmed) return;
        
        try {
            const deleteUrl = '{% url "delete_annotation" document.pk 0 %}'.replace('/0/', `/${annotationId}/`);
            console.log('Deleting annotation at URL:', deleteUrl);
            
            const response = await fetch(deleteUrl, {
                method: 'DELETE',
                headers: {
                    'X-CSRFToken': csrfToken
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const result = await response.json();
            
            if (result.status === 'success') {
                // Remove from existingAnnotations array
                const annotationIndex = existingAnnotations.findIndex(a => a.id === parseInt(annotationId));
                if (annotationIndex !== -1) {
                    existingAnnotations.splice(annotationIndex, 1);
                }
                // Remove from UI
                const annotationElement = document.querySelector(`.annotation-item[data-annotation-id="${annotationId}"]`);
                if (annotationElement) {
                    annotationElement.remove();
                }
                
                // Remove highlight from document
                const highlights = document.querySelectorAll('[data-annotation-id]');
                highlights.forEach(highlight => {
                    const ids = highlight.getAttribute('data-annotation-id').split(',');
                    
                    // Check if this highlight contains the annotation to delete
                    if (ids.includes(String(annotationId))) {
                        // If multiple annotations on this span, remove only this one
                        if (ids.length > 1) {
                            // Remove this annotation from the list
                            const newIds = ids.filter(id => id !== String(annotationId));
                            const categories = highlight.getAttribute('data-category').split(',');
                            const idIndex = ids.indexOf(String(annotationId));
                            const newCategories = categories.filter((_, index) => index !== idIndex);
                            
                            // Update attributes
                            highlight.setAttribute('data-annotation-id', newIds.join(','));
                            highlight.setAttribute('data-category', newCategories.join(','));
                            
                            // Recalculate styling for remaining annotations
                            if (newIds.length === 1) {
                                // Only one annotation left, restore single-color styling
                                const remainingAnnotation = existingAnnotations.find(a => a.id === parseInt(newIds[0]));
                                if (remainingAnnotation) {
                                    highlight.style.background = hexToRGBA(remainingAnnotation.color, 0.3);
                                    highlight.style.backgroundColor = hexToRGBA(remainingAnnotation.color, 0.3);
                                    highlight.style.borderBottom = `2px solid ${remainingAnnotation.color}`;
                                    highlight.style.boxShadow = '';
                                    highlight.title = `${remainingAnnotation.category} - Click to delete`;
                                }
                            } else {
                                // Multiple annotations remain, rebuild gradient
                                const remainingAnnotations = newIds.map(id => 
                                    existingAnnotations.find(a => a.id === parseInt(id))
                                ).filter(a => a);
                                
                                if (remainingAnnotations.length > 0) {
                                    // Create gradient with remaining colors
                                    const gradientStops = remainingAnnotations.map((ann, index) => {
                                        const startPercent = (index / remainingAnnotations.length) * 100;
                                        const endPercent = ((index + 1) / remainingAnnotations.length) * 100;
                                        return `${hexToRGBA(ann.color, 0.3)} ${startPercent}%, ${hexToRGBA(ann.color, 0.3)} ${endPercent}%`;
                                    }).join(', ');
                                    
                                    highlight.style.background = `linear-gradient(to bottom, ${gradientStops})`;
                                    highlight.style.backgroundColor = '';
                                    
                                    // Use first annotation's color for border, last for box-shadow
                                    highlight.style.borderBottom = `2px solid ${remainingAnnotations[0].color}`;
                                    if (remainingAnnotations.length > 1) {
                                        highlight.style.boxShadow = `inset 0 -4px 0 -2px ${remainingAnnotations[remainingAnnotations.length - 1].color}`;
                                    } else {
                                        highlight.style.boxShadow = '';
                                    }
                                    
                                    highlight.title = newCategories.join(', ') + ' - Click to delete';
                                }
                            }
                        } else {
                            // Only one annotation, remove the highlight entirely
                            const text = highlight.textContent;
                            highlight.replaceWith(document.createTextNode(text));
                        }
                    }
                });
                
                updateStats();
                showNotification('Annotation deleted', 'success');
            }
        } catch (error) {
            console.error('Error:', error);
            showNotification('Error deleting annotation: ' + error.message, 'error');
        }
    }
    
    // Add delete handlers to existing annotations
    document.querySelectorAll('.delete-annotation').forEach(btn => {
        btn.addEventListener('click', function() {
            deleteAnnotation(this.dataset.id);
        });
    });
    
    // Update statistics
    function updateStats() {
        console.log('=== UPDATING STATS ===');
        const totalAnnotations = document.querySelectorAll('.annotation-item').length;
        console.log('Total annotations found:', totalAnnotations);
        
        // Count annotations by category name
        const categoryCounts = {};
        document.querySelectorAll('.annotation-item').forEach((item, index) => {
            const badge = item.querySelector('.category-badge');
            if (badge) {
                const categoryName = badge.textContent.trim();
                console.log(`Annotation ${index + 1}: category = "${categoryName}"`);
                categoryCounts[categoryName] = (categoryCounts[categoryName] || 0) + 1;
            }
        });
        
        console.log('Category counts:', categoryCounts);
        
        // Calculate parent category totals by summing their subcategories
        const parentTotals = {};
        document.querySelectorAll('.category-option.parent-category').forEach(parentEl => {
            const parentName = parentEl.dataset.categoryName;
            let total = 0;
            
            // Find all subcategories of this parent
            let nextEl = parentEl.nextElementSibling;
            while (nextEl && nextEl.classList.contains('subcategory')) {
                const subcatName = nextEl.dataset.categoryName;
                total += categoryCounts[subcatName] || 0;
                nextEl = nextEl.nextElementSibling;
            }
            
            parentTotals[parentName] = total;
            //console.log(`Parent ${parentName} total: ${total}`);
        });
        
        // Update counts in the category list (inline badges)
        document.querySelectorAll('.category-count-badge').forEach(badge => {
            const category = badge.dataset.countFor;
            const parentEl = badge.closest('.category-option.parent-category');
            
            // If it's a parent category, use the total from subcategories
            const count = parentEl ? (parentTotals[category] || 0) : (categoryCounts[category] || 0);
            
            //console.log(`Inline badge - ${category}: ${count} (parent: ${!!parentEl})`);
            badge.textContent = count;
            // Toggle hidden class instead of display style
            if (count > 0) {
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        });
        
        console.log('=== STATS UPDATE COMPLETE ===');
    }
    
    // Show notification
    function showNotification(message, type) {
        const alert = document.createElement('div');
        alert.className = `alert alert-${type === 'success' ? 'success' : 'danger'} alert-dismissible fade show`;
        alert.style.position = 'fixed';
        alert.style.top = '20px';
        alert.style.right = '20px';
        alert.style.zIndex = '10001';
        alert.innerHTML = `${message}`;
        document.body.appendChild(alert);
        
        setTimeout(() => alert.remove(), 3000);
    }
    
    // Helper function to convert hex to RGBA
    function hexToRGBA(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    
    // Load and highlight existing annotations
    function loadExistingAnnotations() {
        console.log('=== LOADING ANNOTATIONS ===');
        console.log('Total annotations:', existingAnnotations.length);
        
        if (existingAnnotations.length === 0) {
            console.log('No annotations to highlight');
            return;
        }
        
        existingAnnotations.forEach((annotation, index) => {
            console.log(`[${index + 1}] Loading annotation:`, annotation.category);
            
            // Try to restore using XPath if available
            const posData = annotation.positionData || {};
            if (posData.startXPath && posData.endXPath) {
                highlightUsingXPath(annotation, posData);
            } else {
                // Fallback to text search
                highlightUsingTextSearch(annotation);
            }
        });
        
        console.log('=== HIGHLIGHTING COMPLETE ===');
    }
    
    // Highlight using XPath (more reliable)
    function highlightUsingXPath(annotation, posData) {
        try {
            // Check if XPath data is valid
            if (!posData.startXPath || !posData.endXPath || posData.startXPath === '' || posData.endXPath === '') {
                console.warn('Invalid or missing XPath data, using text search');
                highlightUsingTextSearch(annotation);
                return;
            }
            
            const startNode = getNodeFromXPath(posData.startXPath);
            const endNode = getNodeFromXPath(posData.endXPath);
            
            if (!startNode || !endNode) {
                console.warn('Could not find nodes from XPath, falling back to text search');
                highlightUsingTextSearch(annotation);
                return;
            }
            
            const range = document.createRange();
            range.setStart(startNode, posData.startOffset || 0);
            range.setEnd(endNode, posData.endOffset || 0);
            
            // Use the robust highlighting method that handles complex ranges
            applyHighlightToRange(range, annotation);
            console.log('‚úì Highlighted using XPath:', annotation.category);
        } catch (e) {
            console.error('XPath highlighting failed:', e);
            highlightUsingTextSearch(annotation);
        }
    }
    
    // Apply highlight to a range, handling complex cases with images and multiple elements
    function applyHighlightToRange(range, annotation) {
        try {
            // Clone the range to avoid modifying the original
            const workingRange = range.cloneRange();
            
            // Get all nodes in the range
            const contents = workingRange.cloneContents();
            
            // Find all text nodes AND existing highlight spans we need to highlight
            const walker = document.createTreeWalker(
                documentViewer,
                NodeFilter.SHOW_ALL,
                {
                    acceptNode: function(node) {
                        // Accept text nodes
                        if (node.nodeType === Node.TEXT_NODE) {
                            return NodeFilter.FILTER_ACCEPT;
                        }
                        // Accept existing highlight spans (for overlap handling)
                        if (node.nodeType === Node.ELEMENT_NODE && 
                            node.classList && node.classList.contains('highlight')) {
                            return NodeFilter.FILTER_ACCEPT;
                        }
                        return NodeFilter.FILTER_SKIP;
                    }
                },
                false
            );
            
            const nodesToHighlight = [];
            let node;
            
            // Collect all text nodes and highlight spans that are between start and end
            while (node = walker.nextNode()) {
                try {
                    const compareStart = range.comparePoint(node, 0);
                    const compareEnd = range.comparePoint(node, node.nodeType === Node.TEXT_NODE ? node.length : node.childNodes.length);
                
                    // If the node is within or overlaps the range
                    if ((compareStart >= 0 && compareStart <= 0) || 
                        (compareEnd >= 0 && compareEnd <= 0) ||
                        (compareStart < 0 && compareEnd > 0)) {
                        
                        let startOffset = 0;
                        let endOffset = node.nodeType === Node.TEXT_NODE ? node.length : node.childNodes.length;
                        
                        // Adjust offsets if this is a boundary node
                        if (node === range.startContainer) {
                            startOffset = range.startOffset;
                        }
                        if (node === range.endContainer) {
                            endOffset = range.endOffset;
                        }
                        
                        if (startOffset < endOffset || node.nodeType === Node.ELEMENT_NODE) {
                            nodesToHighlight.push({ node, startOffset, endOffset });
                        }
                    }
                } catch (e) {
                    // Skip nodes that can't be compared
                    console.warn('Could not compare node:', e);
                }
            }
            
            console.log(`Found ${nodesToHighlight.length} nodes to highlight`);
            
            // Highlight each node
            nodesToHighlight.forEach(({ node: targetNode, startOffset, endOffset }) => {
                // Handle existing highlight spans (overlapping annotations)
                if (targetNode.nodeType === Node.ELEMENT_NODE && targetNode.classList.contains('highlight')) {
                    // This is already a highlighted span - add overlapping annotation styling
                    const existingIds = targetNode.getAttribute('data-annotation-id') || '';
                    const existingCategories = targetNode.getAttribute('data-category') || '';
                    
                    // Check if this annotation is already applied
                    if (existingIds.split(',').includes(String(annotation.id))) {
                        console.log('Annotation already applied to this highlight, skipping');
                        return;
                    }
                    
                    // Add new annotation ID and category
                    targetNode.setAttribute('data-annotation-id', existingIds + ',' + annotation.id);
                    targetNode.setAttribute('data-category', existingCategories + ',' + annotation.category);
                    
                    // Merge colors by adding a gradient or mixing
                    const existingBg = targetNode.style.backgroundColor;
                    const newBg = hexToRGBA(annotation.color, 0.3);
                    
                    // Create a linear gradient to show both colors
                    targetNode.style.background = `linear-gradient(to bottom, ${existingBg} 50%, ${newBg} 50%)`;
                    
                    // Add a compound border (use box-shadow for additional border)
                    const existingBorder = targetNode.style.borderBottom;
                    targetNode.style.boxShadow = `inset 0 -4px 0 -2px ${annotation.color}`;
                    
                    // Update title to show multiple categories
                    const categories = targetNode.getAttribute('data-category').split(',');
                    targetNode.title = categories.join(', ') + ' - Click to manage';
                    
                    return;
                }
                
                // Check if text node is inside a highlight span
                if (targetNode.nodeType === Node.TEXT_NODE && 
                    targetNode.parentNode && 
                    targetNode.parentNode.classList && 
                    targetNode.parentNode.classList.contains('highlight')) {
                    
                    const highlightSpan = targetNode.parentNode;
                    const existingIds = highlightSpan.getAttribute('data-annotation-id') || '';
                    const existingCategories = highlightSpan.getAttribute('data-category') || '';
                    
                    // Check if this annotation is already applied
                    if (existingIds.split(',').includes(String(annotation.id))) {
                        console.log('Annotation already applied to this highlight, skipping');
                        return;
                    }
                    
                    // Add new annotation ID and category
                    highlightSpan.setAttribute('data-annotation-id', existingIds + ',' + annotation.id);
                    highlightSpan.setAttribute('data-category', existingCategories + ',' + annotation.category);
                    
                    // Merge colors
                    const existingBg = highlightSpan.style.backgroundColor;
                    const newBg = hexToRGBA(annotation.color, 0.3);
                    
                    // Create a linear gradient to show both colors
                    highlightSpan.style.background = `linear-gradient(to bottom, ${existingBg} 50%, ${newBg} 50%)`;
                    
                    // Add a compound border
                    highlightSpan.style.boxShadow = `inset 0 -4px 0 -2px ${annotation.color}`;
                    
                    // Update title
                    const categories = highlightSpan.getAttribute('data-category').split(',');
                    highlightSpan.title = categories.join(', ') + ' - Click to manage';
                    
                    console.log('‚úì Added overlapping annotation to existing highlight');
                    return;
                }
                
                // Handle text nodes (normal highlighting)
                const text = targetNode.textContent;
                const beforeText = text.substring(0, startOffset);
                const highlightText = text.substring(startOffset, endOffset);
                const afterText = text.substring(endOffset);
                
                const parent = targetNode.parentNode;
                
                // Create the highlight span
                const span = document.createElement('span');
                span.className = 'highlight';
                span.setAttribute('data-category', annotation.category);
                span.setAttribute('data-annotation-id', annotation.id);
                span.style.backgroundColor = hexToRGBA(annotation.color, 0.3);
                span.style.borderBottom = `2px solid ${annotation.color}`;
                span.textContent = highlightText;
                span.title = `${annotation.category} - Click to manage`;
                
                // Add click handler for deletion
                span.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const annotationId = this.getAttribute('data-annotation-id');
                    openActionChoiceModal(annotationId);
                });
                
                // Replace the text node with the parts
                if (beforeText) {
                    parent.insertBefore(document.createTextNode(beforeText), targetNode);
                }
                parent.insertBefore(span, targetNode);
                if (afterText) {
                    parent.insertBefore(document.createTextNode(afterText), targetNode);
                }
                parent.removeChild(targetNode);
            });
        } catch (e) {
            console.error('Error applying highlight to range:', e);
        }
    }
    
    // Fallback: highlight using text search
    function highlightUsingTextSearch(annotation) {
        console.log('Using text search for:', annotation.category);
        const text = annotation.text;
        
        if (!text || text.length === 0) return;
        
        // Collect all text nodes AND highlight spans to handle overlaps
        const walker = document.createTreeWalker(
            documentViewer,
            NodeFilter.SHOW_ALL,
            {
                acceptNode: function(node) {
                    // Accept text nodes
                    if (node.nodeType === Node.TEXT_NODE) {
                        return NodeFilter.FILTER_ACCEPT;
                    }
                    // Accept existing highlight spans (for overlap handling)
                    if (node.nodeType === Node.ELEMENT_NODE && 
                        node.classList && node.classList.contains('highlight')) {
                        return NodeFilter.FILTER_ACCEPT;
                    }
                    return NodeFilter.FILTER_SKIP;
                }
            },
            false
        );
        
        let node;
        let fullText = '';
        const nodes = [];
        const processedHighlights = new Set(); // Track highlight spans we've already added
        
        while (node = walker.nextNode()) {
            // If this is a text node inside a highlight span, skip it if we've already added the parent
            if (node.nodeType === Node.TEXT_NODE && 
                node.parentNode && 
                node.parentNode.classList && 
                node.parentNode.classList.contains('highlight')) {
                
                // Skip text nodes inside highlights - we'll handle the highlight span itself
                if (processedHighlights.has(node.parentNode)) {
                    continue;
                }
            }
            
            const nodeText = node.textContent;
            const isHighlight = node.nodeType === Node.ELEMENT_NODE && node.classList.contains('highlight');
            
            // If this is a highlight span, mark it as processed
            if (isHighlight) {
                processedHighlights.add(node);
            }
            
            nodes.push({
                node: node,
                start: fullText.length,
                text: nodeText,
                isHighlight: isHighlight
            });
            fullText += nodeText;
        }
        
        // Find the text in the full text
        const index = fullText.indexOf(text);
        if (index === -1) {
            console.warn('Text not found in document:', text.substring(0, 50));
            return;
        }
        
        const endIndex = index + text.length;
        
        // Find which nodes contain this range
        for (let i = 0; i < nodes.length; i++) {
            const nodeInfo = nodes[i];
            const nodeEnd = nodeInfo.start + nodeInfo.text.length;
            
            // Check if this node overlaps with our target range
            if (nodeEnd > index && nodeInfo.start < endIndex) {
                const localStart = Math.max(0, index - nodeInfo.start);
                const localEnd = Math.min(nodeInfo.text.length, endIndex - nodeInfo.start);
                
                try {
                    const targetNode = nodeInfo.node;
                    
                    // Handle existing highlight spans (overlapping annotations)
                    if (nodeInfo.isHighlight) {
                        const existingIds = targetNode.getAttribute('data-annotation-id') || '';
                        const existingCategories = targetNode.getAttribute('data-category') || '';
                        
                        // Check if this annotation is already applied
                        if (existingIds.split(',').includes(String(annotation.id))) {
                            console.log('Annotation already applied to this highlight, skipping');
                            continue;
                        }
                        
                        // Add new annotation ID and category
                        targetNode.setAttribute('data-annotation-id', existingIds + ',' + annotation.id);
                        targetNode.setAttribute('data-category', existingCategories + ',' + annotation.category);
                        
                        // Merge colors
                        const existingBg = targetNode.style.backgroundColor;
                        const newBg = hexToRGBA(annotation.color, 0.3);
                        
                        // Create a linear gradient to show both colors
                        targetNode.style.background = `linear-gradient(to bottom, ${existingBg} 50%, ${newBg} 50%)`;
                        
                        // Add a compound border
                        targetNode.style.boxShadow = `inset 0 -4px 0 -2px ${annotation.color}`;
                        
                        // Update title
                        const categories = targetNode.getAttribute('data-category').split(',');
                        targetNode.title = categories.join(', ') + ' - Click to manage';
                        
                        console.log('‚úì Added overlapping annotation to existing highlight');
                        continue;
                    }
                    
                    // Handle text nodes that might be inside highlights (shouldn't happen with new logic, but keep as safeguard)
                    if (targetNode.nodeType === Node.TEXT_NODE &&
                        targetNode.parentNode &&
                        targetNode.parentNode.classList &&
                        targetNode.parentNode.classList.contains('highlight')) {
                        console.log('Text node inside highlight detected, applying to parent');
                        const highlightSpan = targetNode.parentNode;
                        const existingIds = highlightSpan.getAttribute('data-annotation-id') || '';
                        const existingCategories = highlightSpan.getAttribute('data-category') || '';
                        
                        // Check if this annotation is already applied
                        if (existingIds.split(',').includes(String(annotation.id))) {
                            console.log('Annotation already applied to parent highlight, skipping');
                            continue;
                        }
                        
                        // Add new annotation ID and category to parent
                        highlightSpan.setAttribute('data-annotation-id', existingIds + ',' + annotation.id);
                        highlightSpan.setAttribute('data-category', existingCategories + ',' + annotation.category);
                        
                        // Merge colors
                        const existingBg = highlightSpan.style.backgroundColor;
                        const newBg = hexToRGBA(annotation.color, 0.3);
                        
                        highlightSpan.style.background = `linear-gradient(to bottom, ${existingBg} 50%, ${newBg} 50%)`;
                        highlightSpan.style.boxShadow = `inset 0 -4px 0 -2px ${annotation.color}`;
                        
                        const categories = highlightSpan.getAttribute('data-category').split(',');
                        highlightSpan.title = categories.join(', ') + ' - Click to manage';
                        
                        console.log('‚úì Added overlapping annotation to parent highlight');
                        continue;
                    }
                    
                    // Handle normal text nodes (normal highlighting)
                    const nodeText = targetNode.textContent;
                    const beforeText = nodeText.substring(0, localStart);
                    const highlightText = nodeText.substring(localStart, localEnd);
                    const afterText = nodeText.substring(localEnd);
                    
                    const parent = targetNode.parentNode;
                    
                    // Create the highlight span
                    const span = document.createElement('span');
                    span.className = 'highlight';
                    span.setAttribute('data-category', annotation.category);
                    span.setAttribute('data-annotation-id', annotation.id);
                    span.style.backgroundColor = hexToRGBA(annotation.color, 0.3);
                    span.style.borderBottom = `2px solid ${annotation.color}`;
                    span.textContent = highlightText;
                    span.title = `${annotation.category} - Click to manage`;
                    
                    // Add click handler for deletion
                    span.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const annotationId = this.getAttribute('data-annotation-id');
                        openActionChoiceModal(annotationId);
                    });
                    
                    // Replace the text node with the parts
                    if (beforeText) {
                        parent.insertBefore(document.createTextNode(beforeText), targetNode);
                    }
                    parent.insertBefore(span, targetNode);
                    if (afterText) {
                        parent.insertBefore(document.createTextNode(afterText), targetNode);
                    }
                    parent.removeChild(targetNode);
                } catch (e) {
                    console.error('Failed to highlight node:', e);
                }
            }
        }
        
        console.log('‚úì Highlighted using text search:', annotation.category);
    }
    
    // Fetch suggested categories
    async function fetchSuggestions(text) {
        const suggestedSection = document.getElementById('suggestedCategoriesSection');
        const suggestedList = document.getElementById('suggestedCategoriesList');
        
        if (!suggestedSection || !suggestedList) return;
        
        // Show loading state
        suggestedSection.style.display = 'block';
        suggestedList.innerHTML = '<div style="padding:5px; font-style:italic; color:#999; font-size: 0.9em;">Thinking...</div>';
        
        try {
            const response = await fetch('{% url "suggest_categories" %}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify({ text: text })
            });
            
            const result = await response.json();
            
            if (result.status === 'success') {
                if (result.embedding) {
                    currentEmbedding = result.embedding;
                }
                
                if (result.suggestions && result.suggestions.length > 0) {
                    renderSuggestions(result.suggestions);
                } else {
                // Hide if no suggestions or error
                suggestedSection.style.display = 'none';
                console.log('No suggestions returned', result);
                }
            }
        } catch (error) {
            console.error('Error fetching suggestions:', error);
            suggestedSection.style.display = 'none';
        }
    }

    // Render suggestions
    function renderSuggestions(suggestions) {
        const suggestedList = document.getElementById('suggestedCategoriesList');
        suggestedList.innerHTML = '';
        
        suggestions.forEach(cat => {
            const div = document.createElement('div');
            div.className = 'category-option suggested-category';
            div.style.cssText = `border-left: 4px solid ${cat.color}; margin: 5px 0; padding: 8px; background: white; cursor: pointer; border-radius: 4px; box-shadow: 0 1px 2px rgba(0,0,0,0.05); transition: background 0.2s; border: 1px solid #eee;`;
            div.setAttribute('data-category', cat.name);
            // data-toggle="tooltip" data-placement="right" title="{{ category.description }}
            div.setAttribute('data-toggle', 'tooltip');
            div.setAttribute('data-placement', 'right');
            div.setAttribute('title', cat.description || '');
            
            // Hover effect handled via css class or inline here
            div.onmouseover = function() { this.style.backgroundColor = '#f0f0f0'; };
            div.onmouseout = function() { this.style.backgroundColor = 'white'; };
            
            const scorePercent = Math.round(cat.score * 100);
            
            div.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <span style="font-weight:600; font-size: 0.95em;">${cat.name}</span>
                    <span style="font-size:0.75em; color:white; background:${cat.color}; padding:2px 6px; border-radius:10px; opacity: 0.8;">${scorePercent}% match</span>
                </div>
                ${cat.parent_name ? `<div style="font-size:0.75em; color:#888; margin-top:2px;">in ${cat.parent_name}</div>` : ''}
            `;
            
            div.addEventListener('click', function() {
                saveAnnotation(cat.name);
                categorySelector.style.display = 'none';
            });
            
            suggestedList.appendChild(div);
        });
        $('[data-toggle="tooltip"]').tooltip('dispose');
            $('[data-toggle="tooltip"]').tooltip({
                boundary: 'window',
                container: 'body',
                html: false,
                trigger: 'hover focus'
            });
    }

    // Initial setup
    loadExistingAnnotations();
    // Update stats after a short delay to ensure DOM is ready
    setTimeout(updateStats, 100);
    
    // Collapsible category groups
    document.querySelectorAll('.category-parent-header').forEach(header => {
        header.addEventListener('click', function() {
            const group = this.closest('.category-group');
            group.classList.toggle('collapsed');
        });
    });
});
</script>
{% endblock %}

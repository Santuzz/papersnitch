{% extends "annotator/base.html" %}

{% block extra_css %}

<style> 
    body ::selection {
        background-color: var(--teal);
        color: #000;
    }
    
    /* Zoom Control Styles */
    .zoom-controls {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        align-items: center;
        gap: 2px;
        background: var(--bg-white, #fff);
        border: 1px solid rgba(10, 61, 98, 0.2);
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        padding: 4px;
        z-index: 100;
    }
    
    .zoom-btn {
        height: 32px;
        min-width: 32px;
        padding: 0 8px;
        border: none;
        background: transparent;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        color: var(--primary, #0a3d62);
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: background-color 0.2s ease;
    }
    
    .zoom-btn:hover {
        background: rgba(10, 61, 98, 0.1);
    }
    
    .zoom-btn:active {
        background: rgba(10, 61, 98, 0.2);
    }
    
    .zoom-btn:disabled {
        color: var(--gray, #999);
        cursor: not-allowed;
    }
    
    .zoom-btn:disabled:hover {
        background: transparent;
    }
    
    .zoom-btn.zoom-reset {
        font-size: 12px;
        font-weight: 500;
        margin-left: 4px;
        padding: 0 10px;
        border-left: 1px solid rgba(10, 61, 98, 0.15);
        border-radius: 0 4px 4px 0;
    }
    
    .zoom-level {
        min-width: 50px;
        text-align: center;
        font-size: 14px;
        font-weight: 500;
        color: var(--gray-dark, #333);
        padding: 0 8px;
        border-left: 1px solid rgba(10, 61, 98, 0.1);
        border-right: 1px solid rgba(10, 61, 98, 0.1);
    }
    
</style>
{% endblock %}

{% block content %}
<div class="container-fluid content">
        {% if messages %}
            {% for message in messages %}
                <div class="alert alert-{{ message.tags }} alert-dismissible fade show" role="alert">
                    {{ message }}
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                </div>
            {% endfor %}
        {% endif %}

        
<div class="mb-3">
    <h2>{{ document.title }}</h2>
    <p class="text-muted">
        Uploaded: {{ document.uploaded_at|date:"Y-m-d H:i" }} | 
        <a href="{% url 'document_list' %}">← Back to Documents</a> |
        <a href="{% url 'export_annotations' document.pk %}">Export Annotations</a>
    </p>
</div>

<div class="annotation-container">
    <div class="document-viewer" id="documentViewer">
        <div id="htmlContent">
            {% autoescape off %}
            {{ html_content }}
            {% endautoescape %}
        </div>
        
        <div class="zoom-controls">
            <button id="zoomOut" title="Zoom Out" class="zoom-btn">−</button>
            <span class="zoom-level" id="zoomLevel">100%</span>
            <button id="zoomIn" title="Zoom In" class="zoom-btn">+</button>
            <button id="zoomReset" title="Reset Zoom" class="zoom-btn zoom-reset">Reset</button>
        </div>
    </div>
    
    <div class="annotation-panel">
        <div class="selection-info">
            <strong>How to Annotate:</strong>
            <ol style="margin: 10px 0 0 0; padding-left: 20px; font-size: 0.9em;">
                <li>Select text in the document</li>
                <li>Choose a category from the popup</li>
                <li>Annotation is saved automatically</li>
                <li>You can click on annotations to delete them</li>
            </ol>
        </div>
        
        <h5>Categories</h5>
        <div id="categoryList" class="mb-3">
            {% for category in categories %}
            <div class="category-option mb-2 {% if not category.parent %}parent-category{% else %}subcategory{% endif %}" style="{% if category.parent %}background-color: {{ category.color }}22; {% endif %}border-left: 4px solid {{ category.color }};" data-category-name="{{ category.name }}">
                <strong>{{ category.name }}</strong>
                <span class="category-count-badge" data-count-for="{{ category.name }}">0</span>
                {% if category.description %}
                <div style="font-size: 0.85em; color: #666; clear: both;">{{ category.description }}</div>
                {% endif %}
            </div>
            {% endfor %}
            
            {% if not categories %}
            <p class="text-muted">No categories defined. Please add categories in the admin panel.</p>
            {% endif %}
        </div>
        
        <h5>Annotations</h5>
        <div id="annotationList">
            {% for annotation in annotations %}
            <div class="annotation-item" data-annotation-id="{{ annotation.id }}">
                <div class="category-badge" style="background-color: {{ annotation.category.color|default:'#007bff' }}; color: white;">
                    {{ annotation.category.name }}
                </div>
                <div class="text-preview">"{{ annotation.selected_text|truncatewords:15 }}"</div>
                <small class="text-muted">{{ annotation.created_at|date:"Y-m-d H:i" }}</small>
                <button class="btn btn-sm btn-danger float-end delete-annotation" data-id="{{ annotation.id }}">Delete</button>
            </div>
            {% endfor %}
        </div>
    </div>
</div>

<!-- Category Selector Popup -->
<div id="categorySelector" class="category-selector">
    <div class="category-selector-header">
        <div style="font-weight: bold; color: #333;">Select Category:</div>
        <button class="category-selector-close" id="categorySelectorClose" title="Close (Esc)">×</button>
    </div>
    <div id="categorySelectorOptions">
        {% for category in categories %}
        <div class="category-option {% if not category.parent %}parent-category{% else %}subcategory{% endif %}" data-category="{{ category.name }}" data-category-name="{{ category.name }}" style="border-left: 4px solid {{ category.color }};">
            {{ category.name }}
            <span class="category-count-badge" data-count-for="{{ category.name }}">0</span>
        </div>
        {% endfor %}
    </div>
    <div class="add-category-section">
        <button class="add-category-btn" id="addCategoryBtn">+ Add New Category</button>
        <div class="add-category-form" id="addCategoryForm">
            <input type="text" id="newCategoryName" placeholder="Category name" required>
            <select id="newCategoryParent">
                <option value="">-- Top Level Category --</option>
                {% for category in categories %}
                {% if not category.parent %}
                <option value="{{ category.id }}">{{ category.name }}</option>
                {% endif %}
                {% endfor %}
            </select>
            <input type="color" id="newCategoryColor" value="#3498db" title="Category color">
            <input type="text" id="newCategoryDescription" placeholder="Description (optional)">
            <div class="add-category-form-buttons">
                <button class="btn-save-category" id="saveCategoryBtn">Save</button>
                <button class="btn-cancel-category" id="cancelCategoryBtn">Cancel</button>
            </div>
        </div>
    </div>
</div>
</div>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const documentViewer = document.getElementById('documentViewer');
    const categorySelector = document.getElementById('categorySelector');
    const annotationList = document.getElementById('annotationList');
    let currentSelection = null;
    let currentRange = null;
    
    let currentZoom = 1.0;
    const zoomStep = 0.2;
    const minZoom = 0.5;
    const maxZoom = 3.0;
    
    const htmlContent = document.getElementById('htmlContent');
    const zoomWrapper = document.getElementById('zoomWrapper');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const zoomResetBtn = document.getElementById('zoomReset');
    const zoomLevelDisplay = document.getElementById('zoomLevel');
    
    function updateZoom(newZoom) {
        currentZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
        
        htmlContent.style.transform = `scale(${currentZoom})`;
        htmlContent.style.transformOrigin = 'top left';
        htmlContent.style.transition = 'transform 0.2s ease';
        
        // Adjust wrapper to accommodate scaled content
        htmlContent.style.width = `${100 / currentZoom}%`;
        htmlContent.style.height = `${100 / currentZoom}%`;
        
        zoomLevelDisplay.textContent = Math.round(currentZoom * 100) + '%';
        
        // Update button states
        zoomInBtn.disabled = currentZoom >= maxZoom;
        zoomOutBtn.disabled = currentZoom <= minZoom;
    }
    
    zoomInBtn.addEventListener('click', () => {
        updateZoom(currentZoom + zoomStep);
    });
    
    zoomOutBtn.addEventListener('click', () => {
        updateZoom(currentZoom - zoomStep);
    });
    
    zoomResetBtn.addEventListener('click', () => {
        updateZoom(1.0);
    });
    
    // Keyboard shortcuts for zoom
    document.addEventListener('keydown', (e) => {
        // Ctrl/Cmd + Plus/Equals for zoom in
        if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=')) {
            e.preventDefault();
            updateZoom(currentZoom + zoomStep);
        }
        // Ctrl/Cmd + Minus for zoom out
        else if ((e.ctrlKey || e.metaKey) && e.key === '-') {
            e.preventDefault();
            updateZoom(currentZoom - zoomStep);
        }
        // Ctrl/Cmd + 0 for reset zoom
        else if ((e.ctrlKey || e.metaKey) && e.key === '0') {
            e.preventDefault();
            updateZoom(1.0);
        }
    });
    
    // Mouse wheel zoom (Ctrl + wheel)
    documentViewer.addEventListener('wheel', (e) => {
        if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -zoomStep : zoomStep;
            updateZoom(currentZoom + delta);
        }
    }, { passive: false });
    
    // Initialize button states without applying transform
    zoomInBtn.disabled = currentZoom >= maxZoom;
    zoomOutBtn.disabled = currentZoom <= minZoom;
    
    // CSRF token for POST requests
    const csrfToken = '{{ csrf_token }}';
    
    // console.log('CSRF Token loaded:', csrfToken ? 'Yes' : 'No');
    // console.log('CSRF Token length:', csrfToken.length);
    
    // Category colors mapping
    const categoryColors = {
        {% for category in categories %}
        '{{ category.name }}': '{{ category.color }}',
        {% endfor %}
    };
    
    // Store existing annotations
    const existingAnnotations = [
        {% for ann in annotations_data %}
        {
            id: {{ ann.id }},
            category: '{{ ann.category_name|escapejs }}',
            text: '{{ ann.selected_text|escapejs }}',
            color: '{{ ann.category_color }}',
            positionData: {{ ann.position_data|safe }}
        }{% if not forloop.last %},{% endif %}
        {% endfor %}
    ];
    
    // Text selection handler
    documentViewer.addEventListener('mouseup', function(e) {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        if (selectedText.length > 0) {
            currentSelection = selectedText;
            currentRange = selection.getRangeAt(0);
            
            // Log selection details for debugging
            console.log('Text selected:', {
                length: selectedText.length,
                starts: selectedText.substring(0, 50),
                ends: selectedText.substring(selectedText.length - 50)
            });
            
            // Show category selector at fixed position: mid-left of the screen
            categorySelector.style.display = 'block';
            
            // Position at left: 20px from left edge, vertically centered
            const viewportHeight = window.innerHeight;
            const selectorHeight = categorySelector.offsetHeight || 300; // estimated height if not rendered yet
            
            categorySelector.style.left = '20px';
            categorySelector.style.top = Math.max(20, (viewportHeight - selectorHeight) / 2) + 'px';
            
            // Update selector with preview
            const previewEl = document.getElementById('selectionPreview');
            if (!previewEl) {
                const preview = document.createElement('div');
                preview.id = 'selectionPreview';
                preview.style.cssText = 'font-size:0.85em; color:#666; margin-bottom:8px; padding:8px; background:#f0f0f0; border-radius:4px; max-height:60px; overflow:auto;';
                categorySelector.insertBefore(preview, categorySelector.firstChild);
            }
            const finalPreview = document.getElementById('selectionPreview');
            finalPreview.textContent = `"${selectedText.substring(0, 100)}${selectedText.length > 100 ? '...' : ''}"`;
        }
    });
    
    // Hide selector when clicking outside
    document.addEventListener('mousedown', function(e) {
        if (!categorySelector.contains(e.target) && e.target !== documentViewer) {
            closeCategorySelector();
        }
    });
    
    // Close button handler
    document.getElementById('categorySelectorClose').addEventListener('click', function(e) {
        e.stopPropagation();
        closeCategorySelector();
    });
    
    // ESC key handler
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && categorySelector.style.display === 'block') {
            closeCategorySelector();
        }
    });
    
    // Function to close category selector
    function closeCategorySelector() {
        categorySelector.style.display = 'none';
        // Clear the current selection
        window.getSelection().removeAllRanges();
        currentSelection = null;
        currentRange = null;
    }
    
    // Category selection handler
    document.querySelectorAll('#categorySelectorOptions .category-option').forEach(option => {
        option.addEventListener('click', function() {
            const category = this.dataset.category;
            saveAnnotation(category);
            categorySelector.style.display = 'none';
        });
    });
    
    // Save annotation function
    async function saveAnnotation(category) {
        if (!currentSelection || !currentRange) return;
        
        // Get category color
        const color = categoryColors[category] || '#ffeb3b';
        
        console.log('Saving annotation:', {
            category: category,
            color: color,
            text: currentSelection.substring(0, 80)
        });
        
        // Get the actual text nodes at the start and end of the selection
        let startNode = currentRange.startContainer;
        let endNode = currentRange.endContainer;
        
        // If the container is an element, find the text node at the offset
        if (startNode.nodeType === Node.ELEMENT_NODE) {
            startNode = startNode.childNodes[currentRange.startOffset] || startNode.firstChild;
            // Find the first text node
            while (startNode && startNode.nodeType !== Node.TEXT_NODE) {
                startNode = startNode.firstChild || startNode.nextSibling;
            }
        }
        
        if (endNode.nodeType === Node.ELEMENT_NODE) {
            endNode = endNode.childNodes[currentRange.endOffset - 1] || endNode.lastChild;
            // Find the last text node
            while (endNode && endNode.nodeType !== Node.TEXT_NODE) {
                endNode = endNode.lastChild || endNode.previousSibling;
            }
        }
        
        // Get XPath for the text nodes
        const startXPath = startNode ? getXPath(startNode) : '';
        const endXPath = endNode ? getXPath(endNode) : '';
        
        // Get the actual offsets within the text nodes
        let actualStartOffset = currentRange.startOffset;
        let actualEndOffset = currentRange.endOffset;
        
        // If we had to find a different node, adjust offset
        if (currentRange.startContainer !== startNode) {
            actualStartOffset = 0;
        }
        if (currentRange.endContainer !== endNode) {
            actualEndOffset = endNode ? endNode.length : 0;
        }
        
        console.log('XPath info:', {
            startXPath: startXPath.substring(0, 50),
            endXPath: endXPath.substring(0, 50),
            hasValidXPath: !!(startXPath && endXPath)
        });
        
        // Store the range info for later use
        const rangeInfo = {
            startXPath: startXPath,
            endXPath: endXPath,
            startOffset: actualStartOffset,
            endOffset: actualEndOffset,
            text: currentSelection,
            category: category,
            color: color
        };
        
        const data = {
            category: category,
            selectedText: currentSelection,
            htmlSelector: '',
            positionData: {
                startXPath: startXPath,
                endXPath: endXPath,
                startOffset: actualStartOffset,
                endOffset: actualEndOffset
            }
        };
        
        console.log('Sending data to server:', {
            category: data.category,
            textLength: data.selectedText.length,
            hasXPath: !!(startXPath && endXPath)
        });
        
        try {
            const response = await fetch('{% url "save_annotation" document.pk %}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify(data)
            });
            
            console.log('Response status:', response.status);
            console.log('Response ok:', response.ok);
            
            const result = await response.json();
            console.log('Response data:', result);
            
            if (result.status === 'success') {
                // Apply highlight using the same XPath method that works on page load
                highlightUsingXPath({
                    id: result.annotation_id,
                    category: rangeInfo.category,
                    text: rangeInfo.text,
                    color: rangeInfo.color
                }, rangeInfo);
                
                addAnnotationToList(result.annotation_id, category, currentSelection);
                updateStats();
                showNotification('Annotation saved successfully', 'success');
            } else {
                console.error('Server error:', result);
                showNotification('Error saving annotation: ' + result.message, 'error');
            }
        } catch (error) {
            console.error('Error:', error);
            showNotification('Error saving annotation: ' + error.message, 'error');
        }
        
        // Clear selection
        window.getSelection().removeAllRanges();
        currentSelection = null;
        currentRange = null;
    }
    
    // Get XPath for a node
    function getXPath(node) {
        if (!node) return '';
        
        // If it's a text node, get path to its parent and then add text() selector
        if (node.nodeType === Node.TEXT_NODE) {
            const parent = node.parentNode;
            if (!parent) return '';
            
            // Find the text node index among siblings
            let textIndex = 0;
            for (let i = 0; i < parent.childNodes.length; i++) {
                if (parent.childNodes[i] === node) {
                    break;
                }
                if (parent.childNodes[i].nodeType === Node.TEXT_NODE) {
                    textIndex++;
                }
            }
            
            const parentPath = getXPath(parent);
            return `${parentPath}/text()[${textIndex + 1}]`;
        }
        
        // For element nodes
        if (node.id) {
            return `//*[@id="${node.id}"]`;
        }
        
        const parts = [];
        let currentNode = node;
        
        while (currentNode && currentNode.nodeType === Node.ELEMENT_NODE) {
            let index = 0;
            let sibling = currentNode.previousSibling;
            
            while (sibling) {
                if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName === currentNode.nodeName) {
                    index++;
                }
                sibling = sibling.previousSibling;
            }
            
            const tagName = currentNode.nodeName.toLowerCase();
            const pathIndex = index > 0 ? `[${index + 1}]` : '';
            parts.unshift(tagName + pathIndex);
            currentNode = currentNode.parentNode;
        }
        
        return parts.length ? '/' + parts.join('/') : '';
    }
    
    // Get node from XPath
    function getNodeFromXPath(xpath) {
        try {
            const result = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
            return result.singleNodeValue;
        } catch (e) {
            console.error('XPath evaluation failed:', e);
            return null;
        }
    }
    
    // Add annotation to the list
    function addAnnotationToList(id, category, text) {
        const color = categoryColors[category] || '#007bff';
        const annotationItem = document.createElement('div');
        annotationItem.className = 'annotation-item';
        annotationItem.dataset.annotationId = id;
        annotationItem.innerHTML = `
            <div class="category-badge" style="background-color: ${color}; color: white;">
                ${category}
            </div>
            <div class="text-preview">"${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"</div>
            <small class="text-muted">Just now</small>
            <button class="btn btn-sm btn-danger float-end delete-annotation" data-id="${id}">Delete</button>
        `;
        
        annotationList.insertBefore(annotationItem, annotationList.firstChild);
        
        // Add delete handler
        annotationItem.querySelector('.delete-annotation').addEventListener('click', function() {
            deleteAnnotation(id);
        });
    }
    
    // Delete annotation
    async function deleteAnnotation(annotationId) {
        if (!confirm('Are you sure you want to delete this annotation?')) return;
        
        try {
            const deleteUrl = '{% url "delete_annotation" document.pk 0 %}'.replace('/0/', `/${annotationId}/`);
            console.log('Deleting annotation at URL:', deleteUrl);
            
            const response = await fetch(deleteUrl, {
                method: 'DELETE',
                headers: {
                    'X-CSRFToken': csrfToken
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const result = await response.json();
            
            if (result.status === 'success') {
                // Remove from UI
                const annotationElement = document.querySelector(`.annotation-item[data-annotation-id="${annotationId}"]`);
                if (annotationElement) {
                    annotationElement.remove();
                }
                
                // Remove highlight from document
                const highlights = document.querySelectorAll(`[data-annotation-id="${annotationId}"]`);
                highlights.forEach(highlight => {
                    const text = highlight.textContent;
                    highlight.replaceWith(document.createTextNode(text));
                });
                
                updateStats();
                showNotification('Annotation deleted', 'success');
            }
        } catch (error) {
            console.error('Error:', error);
            showNotification('Error deleting annotation: ' + error.message, 'error');
        }
    }
    
    // Add delete handlers to existing annotations
    document.querySelectorAll('.delete-annotation').forEach(btn => {
        btn.addEventListener('click', function() {
            deleteAnnotation(this.dataset.id);
        });
    });
    
    // Update statistics
    function updateStats() {
        console.log('=== UPDATING STATS ===');
        const totalAnnotations = document.querySelectorAll('.annotation-item').length;
        console.log('Total annotations found:', totalAnnotations);
        
        // Count annotations by category name
        const categoryCounts = {};
        document.querySelectorAll('.annotation-item').forEach((item, index) => {
            const badge = item.querySelector('.category-badge');
            if (badge) {
                const categoryName = badge.textContent.trim();
                console.log(`Annotation ${index + 1}: category = "${categoryName}"`);
                categoryCounts[categoryName] = (categoryCounts[categoryName] || 0) + 1;
            }
        });
        
        console.log('Category counts:', categoryCounts);
        
        // Calculate parent category totals by summing their subcategories
        const parentTotals = {};
        document.querySelectorAll('.category-option.parent-category').forEach(parentEl => {
            const parentName = parentEl.dataset.categoryName;
            let total = 0;
            
            // Find all subcategories of this parent
            let nextEl = parentEl.nextElementSibling;
            while (nextEl && nextEl.classList.contains('subcategory')) {
                const subcatName = nextEl.dataset.categoryName;
                total += categoryCounts[subcatName] || 0;
                nextEl = nextEl.nextElementSibling;
            }
            
            parentTotals[parentName] = total;
            //console.log(`Parent ${parentName} total: ${total}`);
        });
        
        // Update counts in the category list (inline badges)
        document.querySelectorAll('.category-count-badge').forEach(badge => {
            const category = badge.dataset.countFor;
            const parentEl = badge.closest('.category-option.parent-category');
            
            // If it's a parent category, use the total from subcategories
            const count = parentEl ? (parentTotals[category] || 0) : (categoryCounts[category] || 0);
            
            //console.log(`Inline badge - ${category}: ${count} (parent: ${!!parentEl})`);
            badge.textContent = count;
            // Toggle hidden class instead of display style
            if (count > 0) {
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        });
        
        console.log('=== STATS UPDATE COMPLETE ===');
    }
    
    // Show notification
    function showNotification(message, type) {
        const alert = document.createElement('div');
        alert.className = `alert alert-${type === 'success' ? 'success' : 'danger'} alert-dismissible fade show`;
        alert.style.position = 'fixed';
        alert.style.top = '20px';
        alert.style.right = '20px';
        alert.style.zIndex = '10001';
        alert.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        document.body.appendChild(alert);
        
        setTimeout(() => alert.remove(), 3000);
    }
    
    // Helper function to convert hex to RGBA
    function hexToRGBA(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    
    // Load and highlight existing annotations
    function loadExistingAnnotations() {
        console.log('=== LOADING ANNOTATIONS ===');
        console.log('Total annotations:', existingAnnotations.length);
        
        if (existingAnnotations.length === 0) {
            console.log('No annotations to highlight');
            return;
        }
        
        existingAnnotations.forEach((annotation, index) => {
            console.log(`[${index + 1}] Loading annotation:`, annotation.category);
            
            // Try to restore using XPath if available
            const posData = annotation.positionData || {};
            if (posData.startXPath && posData.endXPath) {
                highlightUsingXPath(annotation, posData);
            } else {
                // Fallback to text search
                highlightUsingTextSearch(annotation);
            }
        });
        
        console.log('=== HIGHLIGHTING COMPLETE ===');
    }
    
    // Highlight using XPath (more reliable)
    function highlightUsingXPath(annotation, posData) {
        try {
            // Check if XPath data is valid
            if (!posData.startXPath || !posData.endXPath || posData.startXPath === '' || posData.endXPath === '') {
                console.warn('Invalid or missing XPath data, using text search');
                highlightUsingTextSearch(annotation);
                return;
            }
            
            const startNode = getNodeFromXPath(posData.startXPath);
            const endNode = getNodeFromXPath(posData.endXPath);
            
            if (!startNode || !endNode) {
                console.warn('Could not find nodes from XPath, falling back to text search');
                highlightUsingTextSearch(annotation);
                return;
            }
            
            const range = document.createRange();
            range.setStart(startNode, posData.startOffset || 0);
            range.setEnd(endNode, posData.endOffset || 0);
            
            // Use the robust highlighting method that handles complex ranges
            applyHighlightToRange(range, annotation);
            console.log('✓ Highlighted using XPath:', annotation.category);
        } catch (e) {
            console.error('XPath highlighting failed:', e);
            highlightUsingTextSearch(annotation);
        }
    }
    
    // Apply highlight to a range, handling complex cases with images and multiple elements
    function applyHighlightToRange(range, annotation) {
        try {
            // Clone the range to avoid modifying the original
            const workingRange = range.cloneRange();
            
            // Get all nodes in the range
            const contents = workingRange.cloneContents();
            
            // Find all text nodes we need to highlight
            const walker = document.createTreeWalker(
                documentViewer,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            const textNodesToHighlight = [];
            let node;
            
            // Collect all text nodes that are between start and end
            while (node = walker.nextNode()) {
                const compareStart = range.comparePoint(node, 0);
                const compareEnd = range.comparePoint(node, node.length);
                
                // If the text node is within or overlaps the range
                if ((compareStart >= 0 && compareStart <= 0) || 
                    (compareEnd >= 0 && compareEnd <= 0) ||
                    (compareStart < 0 && compareEnd > 0)) {
                    
                    let startOffset = 0;
                    let endOffset = node.length;
                    
                    // Adjust offsets if this is a boundary node
                    if (node === range.startContainer) {
                        startOffset = range.startOffset;
                    }
                    if (node === range.endContainer) {
                        endOffset = range.endOffset;
                    }
                    
                    if (startOffset < endOffset) {
                        textNodesToHighlight.push({ node, startOffset, endOffset });
                    }
                }
            }
            
            console.log(`Found ${textNodesToHighlight.length} text nodes to highlight`);
            
            // Highlight each text node
            textNodesToHighlight.forEach(({ node: textNode, startOffset, endOffset }) => {
                const text = textNode.textContent;
                const beforeText = text.substring(0, startOffset);
                const highlightText = text.substring(startOffset, endOffset);
                const afterText = text.substring(endOffset);
                
                const parent = textNode.parentNode;
                
                // Create the highlight span
                const span = document.createElement('span');
                span.className = 'highlight';
                span.setAttribute('data-category', annotation.category);
                span.setAttribute('data-annotation-id', annotation.id);
                span.style.backgroundColor = hexToRGBA(annotation.color, 0.3);
                span.style.borderBottom = `2px solid ${annotation.color}`;
                span.textContent = highlightText;
                span.title = `${annotation.category} - Click to delete`;
                
                // Add click handler for deletion
                span.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const annotationId = this.getAttribute('data-annotation-id');
                    deleteAnnotation(annotationId);
                });
                
                // Replace the text node with the parts
                if (beforeText) {
                    parent.insertBefore(document.createTextNode(beforeText), textNode);
                }
                parent.insertBefore(span, textNode);
                if (afterText) {
                    parent.insertBefore(document.createTextNode(afterText), textNode);
                }
                parent.removeChild(textNode);
            });
        } catch (e) {
            console.error('Error applying highlight to range:', e);
        }
    }
    
    // Fallback: highlight using text search
    function highlightUsingTextSearch(annotation) {
        console.log('Using text search for:', annotation.category);
        const text = annotation.text;
        
        if (!text || text.length === 0) return;
        
        // Simple case-sensitive search in the document viewer
        const walker = document.createTreeWalker(
            documentViewer,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        let node;
        let fullText = '';
        const textNodes = [];
        
        while (node = walker.nextNode()) {
            textNodes.push({
                node: node,
                start: fullText.length,
                text: node.textContent
            });
            fullText += node.textContent;
        }
        
        // Find the text in the full text
        const index = fullText.indexOf(text);
        if (index === -1) {
            console.warn('Text not found in document:', text.substring(0, 50));
            return;
        }
        
        const endIndex = index + text.length;
        
        // Find which text nodes contain this range
        for (let i = 0; i < textNodes.length; i++) {
            const nodeInfo = textNodes[i];
            const nodeEnd = nodeInfo.start + nodeInfo.text.length;
            
            // Check if this node overlaps with our target range
            if (nodeEnd > index && nodeInfo.start < endIndex) {
                const localStart = Math.max(0, index - nodeInfo.start);
                const localEnd = Math.min(nodeInfo.text.length, endIndex - nodeInfo.start);
                
                try {
                    const textNode = nodeInfo.node;
                    const nodeText = textNode.textContent;
                    const beforeText = nodeText.substring(0, localStart);
                    const highlightText = nodeText.substring(localStart, localEnd);
                    const afterText = nodeText.substring(localEnd);
                    
                    const parent = textNode.parentNode;
                    
                    // Create the highlight span
                    const span = document.createElement('span');
                    span.className = 'highlight';
                    span.setAttribute('data-category', annotation.category);
                    span.setAttribute('data-annotation-id', annotation.id);
                    span.style.backgroundColor = hexToRGBA(annotation.color, 0.3);
                    span.style.borderBottom = `2px solid ${annotation.color}`;
                    span.textContent = highlightText;
                    span.title = `${annotation.category} - Click to delete`;
                    
                    // Add click handler for deletion
                    span.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const annotationId = this.getAttribute('data-annotation-id');
                        deleteAnnotation(annotationId);
                    });
                    
                    // Replace the text node with the parts
                    if (beforeText) {
                        parent.insertBefore(document.createTextNode(beforeText), textNode);
                    }
                    parent.insertBefore(span, textNode);
                    if (afterText) {
                        parent.insertBefore(document.createTextNode(afterText), textNode);
                    }
                    parent.removeChild(textNode);
                } catch (e) {
                    console.error('Failed to highlight node:', e);
                }
            }
        }
        
        console.log('✓ Highlighted using text search:', annotation.category);
    }
    
    // Add category form handlers
    const addCategoryBtn = document.getElementById('addCategoryBtn');
    const addCategoryForm = document.getElementById('addCategoryForm');
    const saveCategoryBtn = document.getElementById('saveCategoryBtn');
    const cancelCategoryBtn = document.getElementById('cancelCategoryBtn');
    
    addCategoryBtn.addEventListener('click', function() {
        addCategoryForm.classList.add('active');
        addCategoryBtn.style.display = 'none';
    });
    
    cancelCategoryBtn.addEventListener('click', function() {
        addCategoryForm.classList.remove('active');
        addCategoryBtn.style.display = 'block';
        document.getElementById('newCategoryName').value = '';
        document.getElementById('newCategoryDescription').value = '';
    });
    
    saveCategoryBtn.addEventListener('click', async function() {
        const name = document.getElementById('newCategoryName').value.trim();
        const parentId = document.getElementById('newCategoryParent').value;
        const color = document.getElementById('newCategoryColor').value;
        const description = document.getElementById('newCategoryDescription').value.trim();
        
        if (!name) {
            alert('Please enter a category name');
            return;
        }
        
        try {
            const response = await fetch('{% url "create_category" %}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify({
                    name: name,
                    parent_id: parentId || null,
                    color: color,
                    description: description
                })
            });
            
            const result = await response.json();
            
            if (result.status === 'success') {
                showNotification('Category created successfully! Reloading...', 'success');
                // Reload the page to show the new category
                setTimeout(() => location.reload(), 1000);
            } else {
                showNotification('Error: ' + result.message, 'error');
            }
        } catch (error) {
            console.error('Error creating category:', error);
            showNotification('Error creating category: ' + error.message, 'error');
        }
    });
    
    // Initial setup
    loadExistingAnnotations();
    // Update stats after a short delay to ensure DOM is ready
    setTimeout(updateStats, 100);
});
</script>
{% endblock %}
